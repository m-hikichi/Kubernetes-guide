# 2.2. kubectl 応用コマンド

基本的なコマンドに慣れたら、次はアプリケーションの調査やデバッグで役立つ、より応用的なコマンドを学んでいきましょう。

これらのコマンドを使いこなすことで、動いているアプリケーションの内部を覗いたり、問題を特定したりする能力が格段に向上します。

---

#### アプリケーションのログを確認する `kubectl logs`

アプリケーションが正常に動作しているように見えても、内部でエラーが発生していることがあります。`kubectl logs`コマンドを使うと、コンテナ内で実行されているアプリケーションが出力する**標準出力・標準エラー出力（ログ）** を直接確認することができます。

##### ■ 基本的な使い方

```bash
# 特定のPodのログを表示
kubectl logs <Podの名前>
```

もしPod内に複数のコンテナがある場合は、`-c`オプションでコンテナ名を指定する必要があります。

```bash
# Pod内の特定のコンテナのログを表示
kubectl logs <Podの名前> -c <コンテナ名>
```

##### ■ 便利なオプション

###### **-f, --follow: ログをリアルタイムで表示する**

`-f`オプションを付けると、`tail -f`コマンドのように、新しく出力されるログをリアルタイムで表示し続けます。アプリケーションの現在の動作を確認したい場合に非常に便利です。

```bash
# ログをストリーミング表示
kubectl logs -f <Podの名前>
```
（終了するには `Ctrl + C` を押します）

###### **--previous: 前回のコンテナのログを表示する**

Podが何らかの理由でクラッシュし、再起動した場合（`RESTARTS`が1以上の場合）、`kubectl logs`は**現在動作しているコンテナ**のログを表示します。クラッシュする直前のログ、つまり**前回起動していたコンテナ**のログを見るには、`--previous`オプションを使います。

```bash
# クラッシュする前のコンテナのログを表示
kubectl logs --previous <Podの名前>
```

👉 **使いどころ**:
「Podが頻繁に再起動しているが、理由がわからない」という場合に、このコマンドでクラッシュ直前のエラーメッセージを確認することで、問題解決の糸口が見つかります。

##### ■ ラベルを使って複数のPodのログをまとめて見る

Deploymentによって管理されているPodなど、同じ役割を持つ複数のPodのログを一度に確認したい場合があります。その場合は、`-l` (`--selector`) オプションを使って**ラベル**を指定します。

`01-kubernetes-basics.md`で作成した`nginx-app.yaml`では、Deploymentが作るPodに `app: my-nginx` というラベルを付けていました。このラベルを利用します。

```bash
# "app=my-nginx" というラベルが付いたすべてのPodのログを表示
kubectl logs -l app=my-nginx
```

**実行結果**

```
my-nginx-deployment-66b6c48dd5-abcde: 192.168.0.1 - - [01/Jan/2024:12:10:00 +0900] "GET / HTTP/1.1" 200 612 "-" "curl/7.81.0"
my-nginx-deployment-66b6c48dd5-fghij: 192.168.0.1 - - [01/Jan/2024:12:10:01 +0900] "GET / HTTP/1.1" 200 612 "-" "curl/7.81.0"
...
```
このように、どのPodが出力したログなのかが先頭に付与された形で表示されます。

👉 **使いどころ**:
負荷分散しているWebサーバーのアクセスログをまとめて監視したい場合など、複数のPodの動向を一度に把握したいときに非常に強力です。`-f`オプションと組み合わせることもできます (`kubectl logs -f -l app=my-nginx`)。

---

### コンテナの内部を操作する

#### コンテナ内でコマンドを実行する `kubectl exec`

`kubectl exec`は、指定したPod内のコンテナで、任意のコマンドを実行するためのコマンドです。`docker exec`を使ったことがある方にはお馴染みかもしれません。

最もよく使われるのが、コンテナの中に**シェル（対話環境）** を起動して、まるでSSHでログインしたかのようにコンテナ内部を操作する使い方です。

##### ■ 基本的な使い方

```bash
# Pod内のコンテナでシェルを起動する
kubectl exec -it <Podの名前> -- /bin/sh
```

*   `-i` (`--stdin`): 標準入力を有効にします。これにより、キーボードからの入力をコンテナに送ることができます。
*   `-t` (`--tty`): TTY（端末）を割り当てます。これにより、プロンプトが表示され、インタラクティブな操作が可能になります。
*   `--`: コマンドの終わりを示します。これ以降の引数が、コンテナ内で実行するコマンドとして扱われます。

このコマンドを実行すると、プロンプトがコンテナ内のものに切り替わります。

```
/ #  <-- コンテナ内のプロンプト
```

この状態で`ls`や`ps`などのコマンドを打てば、それはコンテナの中で実行されます。

*   `ls -l /app`: アプリケーションのファイルが正しく配置されているか確認する。
*   `cat /etc/resolv.conf`: コンテナの名前解決の設定を確認する。
*   `ps aux`: コンテナ内で動いているプロセスを確認する。

シェルを終了して元のターミナルに戻るには、`exit`コマンドを入力します。

👉 **使いどころ**:
*   「設定ファイルが正しくマウントされているか確認したい」
*   「コンテナの中から外部のDBやAPIに疎通できるか試したい」
*   「一時的にデバッグ用のツールをインストールして調査したい」
といった場合に、コンテナの中に入って直接調査することができます。

##### ■ 複数コンテナを持つPodの場合（特定のコンテナを指定する）

KubernetesのPodは、**1つのPodの中に複数のコンテナを持つことが可能**です。
そのため、**どのコンテナに対してコマンドを実行するか**を明示的に指定する必要があります。

以下のように、`-c` オプションを使ってコンテナ名を指定します。

```bash
# Pod内の特定のコンテナに入る
kubectl exec -it <Podの名前> -c <コンテナ名> -- /bin/sh
```

もし `-c` を省略した場合、

* Podにコンテナが1つしかないときは自動でそのコンテナに接続します
* 複数コンテナがある場合は、**どのコンテナに入るかを指定しないとエラー**になることがあります

##### ■ 単発のコマンドを実行する

シェルを起動せず、特定のコマンドを一回だけ実行することもできます。

```bash
# コンテナ内の環境変数を一覧表示する
kubectl exec <Podの名前> -- printenv

# /app ディレクトリのファイル一覧を表示する
kubectl exec <Podの名前> -- ls -l /app
```

このように、`-it`を付けずにコマンドを指定すると、そのコマンドの実行結果だけがターミナルに表示されます

---

### ローカルPCから直接アクセスする

#### ■ `kubectl port-forward`

`kubectl port-forward`は、自分のPC（ローカル）のポートと、Podのポートを一時的に接続し、**ローカルPCから直接Podのアプリケーションにアクセス**できるようにするコマンドです。

`01-kubernetes-basics.md`では、`Service`リソース（`type: NodePort`）を使って外部にアプリケーションを公開しました。しかし、Serviceをわざわざ作らずに、一時的にPodの動作を確認したい場合も多くあります。`port-forward`は、まさにそのような場面で活躍します。

##### ■ 基本的な使い方

```bash
# ローカルPCの8080番ポートを、指定したPodの80番ポートに接続する
kubectl port-forward <Podの名前> 8080:80
```

このコマンドを実行すると、ターミナルは以下のようなメッセージを表示して待機状態になります。

```
Forwarding from 127.0.0.1:8080 -> 80
Forwarding from [::1]:8080 -> 80
```

この状態で、自分のPCのブラウザで `http://localhost:8080` にアクセスすると、あたかもPodの80番ポートに直接アクセスしているかのように、アプリケーションの画面が表示されます。

接続を終了するには、コマンドを実行したターミナルで `Ctrl + C` を押します。

##### ■ DeploymentやServiceを指定する

Podは名前が変わりやすいため、DeploymentやServiceを指定してポートフォワードすることもできます。その場合、Kubernetesが適切なPodを自動で1つ選んで接続してくれます。

```bash
# "my-nginx-deployment" というDeploymentが管理するPodに接続
kubectl port-forward deployment/my-nginx-deployment 8080:80

# "my-nginx-service" というServiceが接続対象とするPodに接続
kubectl port-forward service/my-nginx-service 8080:80
```
リソースの種類（`deployment/` や `service/`）を名前に含めるのがポイントです。

👉 **使いどころ**:
*   開発中のアプリケーションを、Serviceを作成する前に手元で素早く動作確認したい。
*   データベースPodなど、普段はクラスタの外部に公開していないPodに、手元のDBクライアントから一時的に接続してデータを調査したい。
*   Service経由だと問題が起きる場合に、問題の切り分けとしてPodに直接アクセスして挙動を試したい。

---

### デバッグ用のPodを起動する

#### テスト用のPodを即座に起動する `kubectl run`

`kubectl run`は、マニフェストファイル（YAML）を用意しなくても、コマンド一発で**テストやデバッグ用途のPodを素早く起動**できるコマンドです。

##### ■ 基本的な使い方

```bash
# "busybox" イメージを使って、"debug-pod" という名前のPodを起動し、シェルを実行する
kubectl run debug-pod --image=busybox -it -- /bin/sh
```

*   `--image`: 使用するコンテナイメージを指定します。
*   `-it`: `kubectl exec`の時と同じく、インタラクティブなシェルを起動するためのおまじないです。

このコマンドを実行すると、`debug-pod`という名前のPodが新しく作られ、すぐにそのPodのシェルに接続されます。`exit`でシェルを抜けてもPodは残っているので、後から`kubectl exec`で再び入ることもできます。

使い終わったPodは、`kubectl delete pod debug-pod` で忘れずに削除しましょう。

##### ■ `kubectl apply` との違い

| | `kubectl run` | `kubectl apply -f <file.yaml>` |
| :--- | :--- | :--- |
| **目的** | **一時的・対話的**なデバッグやテスト | **宣言的・永続的**なアプリケーションの管理 |
| **手軽さ** | 非常に手軽。コマンド一発で起動できる。 | マニフェストファイルの作成が必要。 |
| **再現性** | 低い。コマンドのオプションを覚える必要がある。 | 高い。YAMLファイルを見れば構成がわかる。 |
| **管理** | Gitなどでの構成管理には向かない。 | GitでYAMLファイルを管理するのが基本。 |
| **主な用途** | ネットワーク疎通確認、ツールの実行など | 本番・開発環境でのアプリケーションデプロイ |

`kubectl apply`が「**あるべき状態**」をYAMLで定義して管理するのに対し、`kubectl run`は「**今すぐPodを起動して何かしたい**」という命令的な要求に応えるためのコマンドです。

👉 **使いどころ**:
*   **ネットワーク疎通確認**: クラスタ内のPodから、別のPodや外部のサービス（DBなど）に接続できるか試したいとき。`curl`や`ping`コマンドが入ったイメージ（`busybox`や`curlimages/curl`など）でPodを起動し、そこから接続テストを行います。
*   **デバッグツールの実行**: `tcpdump`でパケットキャプチャをしたり、`netcat`でポートのスキャンをしたりなど、特定のツールを使いたい場合に、そのツールが入ったイメージでPodを起動して利用します。
*   **Kubernetesの動作学習**: 「とりあえずPodを一つ動かしてみたい」という学習の初期段階で、YAMLを書かずに手軽に試すことができます。

#### 稼働中のPodにデバッグ用コンテナを接続する `kubectl debug`

`kubectl debug`は、**すでに動いているPodを止めずに**、そのPodに新しいデバッグ用のコンテナ（**サイドカーコンテナ**や**エフェメラルコンテナ**と呼ばれます）を後から追加（アタッチ）するための、比較的新しい強力なコマンドです。

##### ■ なぜ `kubectl debug` が必要なのか？

従来のデバッグでは、以下のような問題がありました。

*   **`kubectl exec`の問題**: アプリケーションのコンテナイメージに、`curl`や`ping`などのデバッグツールが含まれていないことが多い（セキュリティやイメージサイズの観点から）。
*   **`kubectl run`の問題**: 新しいPodを起動するため、デバッグ対象のPodとネットワーク環境などが微妙に異なり、問題の完全な再現が難しいことがある。

`kubectl debug`は、デバッグ対象のPodと**全く同じ環境（ネットワーク空間など）を共有する**デバッグ専用コンテナを、その場で追加することでこれらの問題を解決します。

##### ■ 基本的な使い方

```bash
# "my-target-pod" のコピーを作成し、デバッグ用のシェルを起動する
kubectl debug -it my-target-pod --image=busybox -- /bin/sh
```

*   `-it`: インタラクティブなシェルを起動します。
*   `--image`: デバッグに使うツールが入ったコンテナイメージを指定します。

このコマンドを実行すると、Kubernetesは`my-target-pod`の**コピー**として`my-target-pod-debug`のような名前の新しいPodを作成し、その中で指定した`busybox`コンテナを起動してシェルに接続します。

このデバッグ用Podは、元のPodとネットワーク設定などを共有しているため、`localhost`で元のアプリケーションコンテナにアクセスすることができます。

```bash
# デバッグ用コンテナの中から...

# 元のアプリケーションにアクセスしてみる
/ # wget -O - localhost:80

# 元のPodと同じネットワーク環境から外部にアクセスしてみる
/ # ping google.com
```

デバッグが終わったら、`exit`でシェルを抜け、`kubectl delete pod my-target-pod-debug`でデバッグ用Podを削除します。

👉 **使いどころ**:
*   本番環境で動いているPodの挙動がおかしいが、**サービスを止めることはできない**。そのPodと全く同じ環境で調査を行いたい。
*   アプリケーションコンテナにデバッグツールが入っていないが、ネットワークの問題（名前解決、通信経路など）を調査したい。
*   Distrolessイメージのような、シェルすら含まない軽量なコンテナイメージで動いているアプリケーションをデバッグしたい。
