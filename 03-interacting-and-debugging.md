# 3. コンテナの内部を操作・デバッグする (Interacting and Debugging)

`02-observing-resources.md`では、リソースの状態を外から確認する方法を学びました。この章ではさらに一歩進んで、動いているコンテナの**中に入って**調査したり、自分のPCからアプリケーションに**直接アクセス**したりするための、より対話的なコマンドを学びます。

これらのコマンドは、アプリケーションの挙動がおかしい場合や、特定のリクエストを試したい場合など、深いレベルでのデバッグに不可欠です。

---

### 3.1. コンテナ内でコマンドを実行する `kubectl exec`

`kubectl exec`は、指定したPod内のコンテナで、任意のコマンドを実行するためのコマンドです。`docker exec`を使ったことがある方にはお馴染みかもしれません。

最もよく使われるのが、コンテナの中に**シェル（対話環境）** を起動して、まるでSSHでログインしたかのようにコンテナ内部を操作する使い方です。

#### ■ 基本的な使い方（コンテナにログインする）

コンテナ内で `/bin/sh` や `/bin/bash` を実行することで、コンテナのシェルを起動できます。

```bash
# Pod内のコンテナでシェルを起動する
kubectl exec -it <Podの名前> -- /bin/sh
```

*   `-i` (`--stdin`): 標準入力を有効にします。これにより、キーボードからの入力をコンテナに送ることができます。
*   `-t` (`--tty`): TTY（端末）を割り当てます。これにより、プロンプトが表示され、インタラクティブな操作が可能になります。
*   `--`: コマンドの終わりを示します。これ以降の引数が、コンテナ内で実行するコマンドとして扱われます。

このコマンドを実行すると、プロンプトがコンテナ内のものに切り替わります。

```
/ #  <-- コンテナ内のプロンプト
```

この状態で`ls`や`ps`などのコマンドを打てば、それはコンテナの中で実行されます。

*   `ls -l /app`: アプリケーションのファイルが正しく配置されているか確認する。
*   `cat /etc/resolv.conf`: コンテナの名前解決の設定を確認する。
*   `ps aux`: コンテナ内で動いているプロセスを確認する。

シェルを終了して元のターミナルに戻るには、`exit`コマンドを入力します。

👉 **使いどころ**:
*   「設定ファイルが正しくマウントされているか確認したい」
*   「コンテナの中から外部のDBやAPIに疎通できるか試したい」
*   「一時的にデバッグ用のツールをインストールして調査したい」
といった場合に、コンテナの中に入って直接調査することができます。

#### ■ 単発のコマンドを実行する

シェルを起動せず、特定のコマンドを一回だけ実行することもできます。

```bash
# コンテナ内の環境変数を一覧表示する
kubectl exec <Podの名前> -- printenv

# /app ディレクトリのファイル一覧を表示する
kubectl exec <Podの名前> -- ls -l /app
```

このように、`-it`を付けずにコマンドを指定すると、そのコマンドの実行結果だけがターミナルに表示されます。

---

### 3.2. ローカルPCからPodに直接アクセスする `kubectl port-forward`

`kubectl port-forward`は、自分のPC（ローカル）のポートと、Podのポートを一時的に接続し、**ローカルPCから直接Podのアプリケーションにアクセス**できるようにするコマンドです。

`01-kubernetes-basics.md`では、`Service`リソース（`type: NodePort`）を使って外部にアプリケーションを公開しました。しかし、Serviceをわざわざ作らずに、一時的にPodの動作を確認したい場合も多くあります。`port-forward`は、まさにそのような場面で活躍します。

#### ■ 基本的な使い方

```bash
# ローカルPCの8080番ポートを、指定したPodの80番ポートに接続する
kubectl port-forward <Podの名前> 8080:80
```

このコマンドを実行すると、ターミナルは以下のようなメッセージを表示して待機状態になります。

```
Forwarding from 127.0.0.1:8080 -> 80
Forwarding from [::1]:8080 -> 80
```

この状態で、自分のPCのブラウザで `http://localhost:8080` にアクセスすると、あたかもPodの80番ポートに直接アクセスしているかのように、アプリケーションの画面が表示されます。

接続を終了するには、コマンドを実行したターミナルで `Ctrl + C` を押します。

#### ■ DeploymentやServiceを指定する

Podは名前が変わりやすいため、DeploymentやServiceを指定してポートフォワードすることもできます。その場合、Kubernetesが適切なPodを自動で1つ選んで接続してくれます。

```bash
# "my-nginx-deployment" というDeploymentが管理するPodに接続
kubectl port-forward deployment/my-nginx-deployment 8080:80

# "my-nginx-service" というServiceが接続対象とするPodに接続
kubectl port-forward service/my-nginx-service 8080:80
```
リソースの種類（`deployment/` や `service/`）を名前に含めるのがポイントです。

👉 **使いどころ**:
*   開発中のアプリケーションを、Serviceを作成する前に手元で素早く動作確認したい。
*   データベースPodなど、普段はクラスタの外部に公開していないPodに、手元のDBクライアントから一時的に接続してデータを調査したい。
*   Service経由だと問題が起きる場合に、問題の切り分けとしてPodに直接アクセスして挙動を試したい。

---

### 3.3. テスト用のPodを即座に起動する `kubectl run`

`kubectl run`は、マニフェストファイル（YAML）を用意しなくても、コマンド一発で**テストやデバッグ用途のPodを素早く起動**できるコマンドです。

#### ■ 基本的な使い方

```bash
# "busybox" という軽量イメージを使って、"debug-pod" という名前のPodを起動し、シェルを実行する
kubectl run debug-pod --image=busybox -it -- /bin/sh
```

*   `--image`: 使用するコンテナイメージを指定します。
*   `-it`: `kubectl exec`の時と同じく、インタラクティブなシェルを起動するためのおまじないです。

このコマンドを実行すると、`debug-pod`という名前のPodが新しく作られ、すぐにそのPodのシェルに接続されます。`exit`でシェルを抜けてもPodは残っているので、後から`kubectl exec`で再び入ることもできます。

使い終わったPodは、`kubectl delete pod debug-pod` で忘れずに削除しましょう。

#### ■ `kubectl apply` との違い

| | `kubectl run` | `kubectl apply -f <file.yaml>` |
| :--- | :--- | :--- |
| **目的** | **一時的・対話的**なデバッグやテスト | **宣言的・永続的**なアプリケーションの管理 |
| **手軽さ** | 非常に手軽。コマンド一発で起動できる。 | マニフェストファイルの作成が必要。 |
| **再現性** | 低い。コマンドのオプションを覚える必要がある。 | 高い。YAMLファイルを見れば構成がわかる。 |
| **管理** | Gitなどでの構成管理には向かない。 | GitでYAMLファイルを管理するのが基本。 |
| **主な用途** | ネットワーク疎通確認、ツールの実行など | 本番・開発環境でのアプリケーションデプロイ |

`kubectl apply`が「**あるべき状態**」をYAMLで定義して管理するのに対し、`kubectl run`は「**今すぐPodを起動して何かしたい**」という命令的な要求に応えるためのコマンドです。

👉 **使いどころ**:
*   **ネットワーク疎通確認**: クラスタ内のPodから、別のPodや外部のサービス（DBなど）に接続できるか試したいとき。`curl`や`ping`コマンドが入ったイメージ（`busybox`や`curlimages/curl`など）でPodを起動し、そこから接続テストを行います。
*   **デバッグツールの実行**: `tcpdump`でパケットキャプチャをしたり、`netcat`でポートのスキャンをしたりなど、特定のツールを使いたい場合に、そのツールが入ったイメージでPodを起動して利用します。
*   **Kubernetesの動作学習**: 「とりあえずPodを一つ動かしてみたい」という学習の初期段階で、YAMLを書かずに手軽に試すことができます。

---

### 3.4. 稼働中のPodにデバッグ用コンテナを接続する `kubectl debug`

`kubectl debug`は、**すでに動いているPodを止めずに**、そのPodに新しいデバッグ用のコンテナ（**サイドカーコンテナ**や**エフェメラルコンテナ**と呼ばれます）を後から追加（アタッチ）するための、比較的新しい強力なコマンドです。

#### ■ なぜ `kubectl debug` が必要なのか？

従来のデバッグでは、以下のような問題がありました。

*   **`kubectl exec`の問題**: アプリケーションのコンテナイメージに、`curl`や`ping`などのデバッグツールが含まれていないことが多い（セキュリティやイメージサイズの観点から）。
*   **`kubectl run`の問題**: 新しいPodを起動するため、デバッグ対象のPodとネットワーク環境などが微妙に異なり、問題の完全な再現が難しいことがある。

`kubectl debug`は、デバッグ対象のPodと**全く同じ環境（ネットワーク空間など）を共有する**デバッグ専用コンテナを、その場で追加することでこれらの問題を解決します。

#### ■ 基本的な使い方

```bash
# "my-target-pod" というPodのコピーを作成し、デバッグ用のシェルを起動する
kubectl debug -it my-target-pod --image=busybox -- /bin/sh
```

*   `-it`: インタラクティブなシェルを起動します。
*   `--image`: デバッグに使うツールが入ったコンテナイメージを指定します。

このコマンドを実行すると、Kubernetesは`my-target-pod`の**コピー**として`my-target-pod-debug`のような名前の新しいPodを作成し、その中で指定した`busybox`コンテナを起動してシェルに接続します。

このデバッグ用Podは、元のPodとネットワーク設定などを共有しているため、`localhost`で元のアプリケーションコンテナにアクセスすることができます。

```bash
# デバッグ用コンテナの中から...

# 元のアプリケーションにアクセスしてみる
/ # wget -O - localhost:80

# 元のPodと同じネットワーク環境から外部にアクセスしてみる
/ # ping google.com
```

デバッグが終わったら、`exit`でシェルを抜け、`kubectl delete pod my-target-pod-debug`でデバッグ用Podを削除します。

👉 **使いどころ**:
*   本番環境で動いているPodの挙動がおかしいが、**サービスを止めることはできない**。そのPodと全く同じ環境で調査を行いたい。
*   アプリケーションコンテナにデバッグツールが入っていないが、ネットワークの問題（名前解決、通信経路など）を調査したい。
*   Distrolessイメージのような、シェルすら含まない軽量なコンテナイメージで動いているアプリケーションをデバッグしたい。
